<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Ionic.Utils.Zip</name>
    </assembly>
    <members>
        <member name="T:Ionic.Utils.Zip.SelfExtractorFlavor">
            <summary>
            An enum that provides the different self-extractor flavors
            </summary>
        </member>
        <member name="F:Ionic.Utils.Zip.SelfExtractorFlavor.ConsoleApplication">
            <summary>
            runs from the command line
            </summary>
        </member>
        <member name="F:Ionic.Utils.Zip.SelfExtractorFlavor.WinFormsApplication">
            <summary>
            graphical app that pops up a GUI
            </summary>
        </member>
        <member name="T:Ionic.Utils.Zip.ZipFile">
            <summary>
            The ZipFile type represents a zip archive file.  This is the main type in the 
            class library that reads and writes zip files, as defined in the format
            for zip described by PKWare.  This implementation is based on the
            System.IO.Compression.DeflateStream base class in the .NET Framework
            base class library, for v2.0 and later.
            </summary>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.SaveSelfExtractor(System.String,Ionic.Utils.Zip.SelfExtractorFlavor)">
            <summary>
            Saves the ZipFile instance to a self-extracting zip archive.
            </summary>
            <remarks>
            <para>
            The generated exe image will execute on any machine that has the .NET Framework 2.0 installed on it. 
            </para>
            <para>
            There are two "flavors" of self-extracting archive.  The <c>WinFormsApplication</c> version will pop up a 
            GUI and allow the user to select a target directory into which to extract. There's also a checkbox
            allowing the user to specify to overwrite existing files, and another checkbox to allow the user
            to request that Explorer be opened to see the extracted files after extraction.  The other flavor
            is <c>ConsoleApplication</c>.  A self-extractor generated with that flavor setting will run from 
            the command line. It accepts command-line options to set the overwrite behavior, and to specify 
            the target extraction directory. 
            </para>
            <para>
            There are a few temporary files created during the saving to a self-extracting zip. 
            These files are normally stored in the directory pointed to by the TEMP environment
            variable, and they are removed upon successful completion of this method. 
            </para>
            </remarks>
            
            <example>
            <code>
            string DirectoryPath = "c:\\Documents\\Project7";
            using (ZipFile zip = new ZipFile())
            {
                zip.AddDirectory(DirectoryPath, System.IO.Path.GetFileName(DirectoryPath));
                zip.Comment = "This will be embedded into a self-extracting console-based exe";
                zip.SaveSelfExtractor("archive.exe", SelfExtractorFlavor.ConsoleApplication);
            }
            </code>
            <code lang="VB">
            Dim DirectoryPath As String = "c:\Documents\Project7"
            Using zip As New ZipFile()
                zip.AddDirectory(DirectoryPath, System.IO.Path.GetFileName(DirectoryPath))
                zip.Comment = "This will be embedded into a self-extracting console-based exe"
                zip.SaveSelfExtractor("archive.exe", SelfExtractorFlavor.ConsoleApplication)
            End Using
            </code>
            </example>
            
            <param name="ExeToGenerate">a pathname, possibly fully qualified, to be created. Typically it will end in an .exe extension.</param>
            <param name="flavor">Indicates whether a Winforms or Console self-extractor is desired.</param>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.#ctor(System.String)">
             <summary>
             Creates a new ZipFile instance, using the specified ZipFileName for the filename. 
             The ZipFileName may be fully qualified.
             </summary>
             
             <remarks>
             <para>
             Applications can use this constructor to create a new ZipFile for writing, 
             or to slurp in an existing zip archive for read and write purposes.  
             </para>
             
             <para>
             To create a new zip archive, an application should call this constructor,
             passing the name of a file that does not exist.  Then the application can
             add directories or files to the ZipFile via <c>AddDirectory()</c>,
             <c>AddFile()</c>, <c>AddItem()</c> and then write the zip archive to the
             disk by calling <c>Save()</c>. The zip file is not actually written to
             the disk until the application calls <c>ZipFile.Save()</c>.  At that point
             the new zip file with the given name is created. 
             </para>
             
             <para>
             To read an existing zip archive, the application should call this constructor,
             passing the name of a valid zip file that does exist.  The file is then read into
             the <c>ZipFile</c> instance.  The app can then enumerate the entries or can modify
             the zip file, for example adding entries, removing entries, changing comments, and
             so on.  When reading an existing zip archive, the application may wish to
             explicitly specify that it is reading an existing zip file by using
             <c>ZipFile.Read()</c>.  On the other hand, this parameterized constructor allows
             applications to use the same code to add items to a zip archive, regardless of
             whether the zip file exists.
             </para>
             
             <para>
             To encrypt the data for the  files added to the ZipFile instance, set the Password
             property after creating the ZipFile instance.
             </para>
             
             </remarks>
            
             <example>
             This example shows how to create a zipfile, and add a few files into it. 
             <code>
             using (ZipFile zip = new ZipFile(args[0]))
             { 
               // Store all files found in the top level directory, into the zip archive.
               String[] filenames = System.IO.Directory.GetFiles(args[1]);
               foreach (String filename in filenames)
               {
                 Console.WriteLine("Adding {0}...", filename);
                 zip.AddFile(filename);
               }  
               zip.Save();
             }
             </code>
             
             <code lang="VB">
             Dim ZipToCreate As String = "ex1.zip"
             Dim DirectoryToZip As String = "c:\temp"
             Using zip As ZipFile = New ZipFile(ZipToCreate)
                 Dim filenames As String() = System.IO.Directory.GetFiles(DirectoryToZip)
                 Dim filename As String
                 For Each filename In filenames
                     Console.WriteLine("Adding {0}...", filename)
                     zip.AddFile(filename)
                 Next
                 zip.Save
             End Using
             </code>
             </example>
            
             <param name="ZipFileName">The filename to use for the new zip archive.</param>
            
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.#ctor">
             <summary>
             Create a zip file, without specifying a target filename to save to. 
             </summary>
             
             <remarks>
             If you do eventually call <c>Save()</c>, you will need to have specified
             a zip filename at some point. Either as a parameter to <c>Save()</c> or 
             on the ZipFile object itself.
             </remarks>
             
             <example>
             This example creates a Zip archive called Backup.zip, containing all the files
             in the directory DirectoryToZip. Files within subdirectories are not zipped up.
             <code>
             using (ZipFile zip = new ZipFile())
             { 
               // Store all files found in the top level directory, into the zip archive.
               // note: this code does not recurse subdirectories!
               String[] filenames = System.IO.Directory.GetFiles(DirectoryToZip);
               foreach (String filename in filenames)
               {
                 Console.WriteLine("Adding {0}...", filename);
                 zip.AddFile(filename);
               }  
               zip.Save("Backup.zip");
             }
             </code>
            
             <code lang="VB">
             Using zip As New ZipFile
                 ' Store all files found in the top level directory, into the zip archive.
                 ' note: this code does not recurse subdirectories!
                 Dim filenames As String() = System.IO.Directory.GetFiles(DirectoryToZip)
                 Dim filename As String
                 For Each filename In filenames
                     Console.WriteLine("Adding {0}...", filename)
                     zip.AddFile(filename)
                 Next
                 zip.Save("Backup.zip")
             End Using
             </code>
             </example>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.#ctor(System.String,System.IO.TextWriter)">
             <summary>
             Creates a new ZipFile instance, using the specified ZipFileName for the filename. 
             The ZipFileName may be fully qualified.
             </summary>
            
             <remarks>
             <para>
             Applications can use this constructor to create a new ZipFile for writing, 
             or to slurp in an existing zip archive for read and write purposes.  
             </para>
            
             <para>
             To create a new zip archive, an application should call this constructor,
             passing the name of a file that does not exist.  Then the application can
             add directories or files to the ZipFile via <c>AddDirectory()</c>,
             <c>AddFile()</c>, <c>AddItem()</c> and then write the zip archive to the
             disk by calling <c>Save()</c>. The zip file is not actually written to
             the disk until the application calls <c>ZipFile.Save()</c>.  At that point
             the new zip file with the given name is created. 
             </para>
             
             <para>
             To read an existing zip archive, the application should call this constructor,
             passing the name of a valid zip file that does exist.  The file is then read into
             the <c>ZipFile</c> instance.  The app can then enumerate the entries or can modify
             the zip file, for example adding entries, removing entries, changing comments, and
             so on.  When reading an existing zip archive, the application may wish to
             explicitly specify that it is reading an existing zip file by using
             <c>ZipFile.Read()</c>.  On the other hand, this parameterized constructor allows
             applications to use the same code to add items to a zip archive, regardless of
             whether the zip file exists.
             </para>
             
             <para>
             This version of the constructor allows the caller to pass in a TextWriter, to which
             verbose messages will be written during extraction or creation of the zip archive.
             A console application may wish to pass System.Console.Out to get messages on the
             Console. A graphical or headless application may wish to capture the messages in a
             different <c>TextWriter</c>, for example, a <c>StringWriter</c>.
             </para>
            
             <para>
             To encrypt the data for the  files added to the ZipFile instance, set the Password
             property after creating the ZipFile instance.
             </para>
             
             </remarks>
            
             <example>
             <code>
             using (ZipFile zip = new ZipFile("Backup.zip", System.Console.Out))
             { 
               // Store all files found in the top level directory, into the zip archive.
               // note: this code does not recurse subdirectories!
               String[] filenames = System.IO.Directory.GetFiles(DirectoryToZip);
               foreach (String filename in filenames)
               {
                 Console.WriteLine("Adding {0}...", filename);
                 zip.AddFile(filename);
               }  
               zip.Save();
             }
             </code>
            
             <code lang="VB">
             Using zip As New ZipFile("Backup.zip", System.Console.Out)
                 ' Store all files found in the top level directory, into the zip archive.
                 ' note: this code does not recurse subdirectories!
                 Dim filenames As String() = System.IO.Directory.GetFiles(DirectoryToZip)
                 Dim filename As String
                 For Each filename In filenames
                     Console.WriteLine("Adding {0}...", filename)
                     zip.AddFile(filename)
                 Next
                 zip.Save
             End Using
             </code>
             </example>
             
             <param name="ZipFileName">The filename to use for the new zip archive.</param>
             <param name="StatusMessageWriter">A TextWriter to use for writing verbose status messages.</param>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.#ctor(System.IO.Stream)">
             <summary>
             Constructor to create an instance of ZipFile that writes Zip archives to a stream.
             </summary>
             
             <remarks>
             
             <para>
             Applications can use this constructor to create an instance of ZipFile 
             for writing to a stream. This is useful when zipping up content, but for any 
             reason it is not desirable to create a zip file in the filesystem itself. 
             </para>
            
             <para>
             Typically an application writing a zip archive in this manner will create and
             open a stream, then call this constructor, passing in the stream.  Then the app will add 
             directories or files to the ZipFile via AddDirectory or AddFile or AddItem.  The app
             will then write the zip archive to the memory stream by calling <c>Save()</c>. The 
             compressed (zipped) data is not actually written to the stream until the application 
             calls <c>ZipFile.Save()</c> .
             </para>
            
             </remarks>
             
             <exception cref="T:System.ArgumentException">
             Thrown if the stream is not writable.  Seriously, think about it, dude. 
             You need a writable stream if you're going to extract zip content to it. 
             </exception>
            
             <example>
             <code>
                byte[] buffer= new byte[100000]; // 100k max
                System.IO.MemoryStream ms= new System.IO.MemoryStream(buffer);
            
                // write to the memory stream:
                try
                {
                  using (ZipFile zip = new ZipFile(ms,System.Console.Out))
                  {
                    zip.Comment= "This is the comment attached to the archive.";
                    zip.AddItem(directoryName);  // and recurse
                    zip.Save(); // write all the data to the stream and close it
                  }
                }
                catch (System.Exception ex1)
                {
                  System.Console.Error.WriteLine("exception: " + ex1);
                }
             </code>
             <code lang="VB">
               Dim buffer As Byte() = New Byte(100000) {}
               Dim ms As New System.IO.MemoryStream(buffer)
               ' write to the memory stream:
               Try 
                   Using zip As ZipFile = New ZipFile(ms, Console.Out)
                       zip.Comment = "This is the comment attached to the archive."
                       ' Add directory and recurse
                       zip.AddItem(NameOfDirectoryToZip)
                       ' now, write all the data to the stream and close it:
                       zip.Save
                   End Using
               Catch ex1 As Exception
                   Console.Error.WriteLine("exception: {0}", ex1.ToString())
               End Try
             </code>
             </example>
            
             <param name="OutputStream">The <c>System.IO.Stream</c> to write to. It must be writable.</param>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.#ctor(System.IO.Stream,System.IO.TextWriter)">
             <summary>
             Constructor to create an instance of ZipFile that writes Zip archives to a stream.
             </summary>
             
             <remarks>
             <para>Applications can use this constructor to create an instance of ZipFile 
             for writing to a stream. This is useful when zipping up content, but for any 
             reason it is not desirable to create a zip file in the filesystem itself. 
             </para>
             <para>Typically an application writing a zip archive in this manner will create and
             open a stream, then call this constructor, passing in the stream.  Then the app will 
             add directories or files to the ZipFile via AddDirectory or AddFile or AddItem.  The 
             app will then write the zip archive to the memory stream by calling <c>Save()</c>. The 
             compressed (zipped) data is not actually written to the stream until the application 
             calls <c>ZipFile.Save()</c> .
             </para>
             <para>
             This version of the constructor allows the caller to pass in a TextWriter, to which  
             verbose messages will be written during creation of the zip archive.  A console 
             application may wish to pass System.Console.Out to get messages on the Console. 
             A graphical or headless application may wish to capture the messages in a different 
             TextWriter. 
             </para>
             </remarks>
            
             <exception cref="T:System.ArgumentException">
             Thrown if the stream is not writable. 
             You need to specify a writable stream if you're going to extract zip content to it. 
             </exception>
            
             <param name="OutputStream">The outputStream to write to. It must be writable.</param>
             <param name="StatusMessageWriter">A TextWriter to use for writing verbose status messages.</param>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.AddItem(System.String)">
             <summary>
             Adds an item, either a file or a directory, to a zip file archive.  
             </summary>
             
             <remarks>
             <para>
             If adding a directory, the add is recursive on all files and subdirectories 
             contained within it. 
             </para>
             <para>
             The name of the item may be a relative path or a fully-qualified path.
             The item added by this call to the ZipFile is not written to the zip file
             archive until the application calls Save() on the ZipFile. 
             </para>
             <para>
             The directory name used for the file within the archive is the same as
             the directory name (potentially a relative path) specified in the FileOrDirectoryName.
             </para>
             </remarks>
            
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.AddFile(System.String)"/>
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.AddDirectory(System.String)"/>
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.UpdateItem(System.String)"/>
            
             <overloads>This method has two overloads.</overloads>
             <param name="FileOrDirectoryName">the name of the file or directory to add.</param>
             
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.AddItem(System.String,System.String)">
             <summary>
             Adds an item, either a file or a directory, to a zip file archive, 
             explicitly specifying the directory path to be used in the archive. 
             </summary>
             
             <remarks>
             <para>
             If adding a directory, the add is recursive on all files and subdirectories 
             contained within it. 
             </para>
             <para>
             The name of the item may be a relative path or a fully-qualified path.
             The item added by this call to the ZipFile is not written to the zip file
             archive until the application calls Save() on the ZipFile. 
             </para>
             
             <para>
             This version of the method allows the caller to explicitly specify the 
             directory path to be used in the archive, which would override the 
             "natural" path of the filesystem file.
             </para>
             
             <para>
             Encryption will be used on the file data if the Password
             has been set on the ZipFile object, prior to calling this method.
             </para>
             
             </remarks>
             
             <exception cref="T:System.IO.FileNotFoundException">
             Thrown if the file or directory passed in does not exist. 
             </exception>
            
             <param name="FileOrDirectoryName">the name of the file or directory to add.</param>
             <param name="DirectoryPathInArchive">
             The name of the directory path to use within the zip archive. 
             This path need not refer to an extant directory in the current filesystem.
             If the files within the zip are later extracted, this is the path used for the extracted file. 
             Passing null (nothing in VB)) will use the path on the FileOrDirectoryName.  Passing the empty string ("")
             will insert the item at the root path within the archive. 
             </param>
             
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.AddFile(System.String,System.String)"/>
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.AddDirectory(System.String,System.String)"/>
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.UpdateItem(System.String,System.String)"/>
            
             <example>
             This example shows how to zip up a set of files into a flat hierarchy, 
             regardless of where in the filesystem the files originated.
             <code>
             String[] filenames= { 
               "c:\\temp\\Readme.txt",
               "MyProposal.docx",
               "images\\Image1.jpg"
             };
            
             try
             {
               using (ZipFile zip = new ZipFile(ZipToCreate,System.Console.Out))
               {
                 for (int i = 1; i &lt; filenames.Length; i++)
                 {
                   // will add Files or Dirs, recurses and flattens subdirectories,
                   zip.AddItem(filenames[i],"flat"); 
                 }
                 zip.Save();
               }
             }
             catch (System.Exception ex1)
             {
               System.Console.Error.WriteLine("exception: {0}", ex1);
             }
             </code>
            
             <code lang="VB">
               Dim filenames As String() = _
                 New String() { "c:\temp\Readme.txt", _
                                "MyProposal.docx", _
                                "images\Image1.jpg" }
               Try 
                   Using zip As New ZipFile(ZipToCreate, Console.Out)
                       Dim i As Integer
                       For i = 1 To filenames.Length - 1
                           ' will add Files or Dirs, recursing and flattening subdirectories.
                           zip.AddItem(filenames(i), "flat")
                       Next i
                       zip.Save
                   End Using
               Catch ex1 As Exception
                   Console.Error.WriteLine("exception: {0}", ex1.ToString())
               End Try
             </code>
             </example>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.AddFile(System.String)">
             <summary>
             Adds a File to a Zip file archive. 
             </summary>
             <remarks>
             The file added by this call to the ZipFile is not written to the zip file
             archive until the application calls Save() on the ZipFile. 
             </remarks>
             
             <example>
             <para>
             In this example, three files are added to a Zip archive. The ReadMe.txt file
             will be placed in the root of the archive. The .png file will be placed in a folder 
             within the zip called photos\personal.  The pdf file will be included into a
             folder within the zip called Desktop.
             </para>
             <code>
                try
                {
                  using (ZipFile zip = new ZipFile("test2.zip",System.Console.Out))
                  {
                    zip.AddFile("c:\\photos\\personal\\7440-N49th.png");
                    zip.AddFile("c:\\Desktop\\2005_Annual_Report.pdf");
                    zip.AddFile("ReadMe.txt");
            
                    zip.Save();
                  }
                }
                catch (System.Exception ex1)
                {
                  System.Console.Error.WriteLine("exception: " + ex1);
                }
             </code>
             
             <code lang="VB">
              Try 
                   Using zip As ZipFile = New ZipFile("test2.zip", Console.Out)
                       zip.AddFile("c:\photos\personal\7440-N49th.png")
                       zip.AddFile("c:\Desktop\2005_Annual_Report.pdf")
                       zip.AddFile("ReadMe.txt")
                       zip.Save
                   End Using
               Catch ex1 As Exception
                   Console.Error.WriteLine("exception: {0}", ex1.ToString)
               End Try
             </code>
             </example>
             
             <overloads>This method has two overloads.</overloads>
             
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.AddItem(System.String)"/>
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.AddDirectory(System.String)"/>
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.UpdateFile(System.String)"/>
            
             <param name="FileName">
             The name of the file to add. It should refer to a file in the filesystem.  
             The name of the file may be a relative path or a fully-qualified path. 
             </param>
             <returns>The ZipEntry corresponding to the File added.</returns>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.AddFile(System.String,System.String)">
             <summary>
             Adds a File to a Zip file archive, potentially overriding the path to be used
             within the zip archive.
             </summary>
             
             <remarks>
             <para>
             The file added by this call to the ZipFile is not written to the zip file
             archive until the application calls Save() on the ZipFile. 
             </para>
             
             <para>
             This version of the method allows the caller to explicitly specify the 
             directory path to be used in the archive. 
             </para>
             
             </remarks>
             
             <example>
             <para>
             In this example, three files are added to a Zip archive. The ReadMe.txt file
             will be placed in the root of the archive. The .png file will be placed in a folder 
             within the zip called images.  The pdf file will be included into a
             folder within the zip called files\documents, and will be encrypted with the 
             given password.
             </para>
             <code>
             try
             {
               using (ZipFile zip = new ZipFile("Archive.zip",System.Console.Out))
               {
                 zip.AddFile("c:\\datafiles\\ReadMe.txt", "");
                 zip.AddFile("c:\\photos\\personal\\7440-N49th.png", "images");
                 zip.Password = "EncryptMe!";
                 zip.AddFile("c:\\Desktop\\2005_Annual_Report.pdf", "files\\documents");
                 zip.Save();
               }
             }
             catch (System.Exception ex1)
             {
               System.Console.Error.WriteLine("exception: {0}", ex1);
             }
             </code>
             
             <code lang="VB">
               Try 
                   Using zip As ZipFile = New ZipFile("Archive.zip", Console.Out)
                       zip.AddFile("c:\datafiles\ReadMe.txt", "")
                       zip.AddFile("c:\photos\personal\7440-N49th.png", "images")
                       zip.Password = "EncryptMe!"
                       zip.AddFile("c:\Desktop\2005_Annual_Report.pdf", "files\documents")
                       zip.Save
                   End Using
               Catch ex1 As Exception
                   Console.Error.WriteLine("exception: {0}", ex1)
               End Try
             </code>
             </example>
             
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.AddItem(System.String,System.String)"/>
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.AddDirectory(System.String,System.String)"/>
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.UpdateFile(System.String,System.String)"/>
            
             <param name="FileName">
             The name of the file to add.  The name of the file may be a relative path or 
             a fully-qualified path.
             </param>
            
             <param name="DirectoryPathInArchive">
             Specifies a directory path to use to override any path in the FileName.
             This path may, or may not, correspond to a real directory in the current filesystem.
             If the files within the zip are later extracted, this is the path used for the extracted file. 
             Passing null (nothing in VB) will use the path on the FileName, if any.  Passing the empty string ("")
             will insert the item at the root path within the archive. 
             </param>
            
             <returns>The ZipEntry corresponding to the file added.</returns>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.UpdateFile(System.String)">
             <summary>
             Adds or Updates a File in a Zip file archive.
             </summary>
             
             <remarks>
             <para>
             This method adds a file to a zip archive, or, if the file already exists in the zip archive, 
             this method Updates the content of that given filename in the zip archive.
             </para>
            
             <para>
             Upon success, there is no way for the application to learn whether the file was added or updated. 
             </para>
            
             </remarks>
            
             <example>
             This example shows how to Update an existing entry in a zipfile. The first call to 
             UpdateFile adds the file to the newly-created zip archive.  The second 
             call to UpdateFile updates the content for that file in the zip archive.
             <code>
             using (ZipFile zip1 = new ZipFile())
             {
               zip1.UpdateFile("MyDocuments\\Readme.txt", "");
               zip1.Comment = "This zip archive has been created.";
               zip1.Save("Content.zip");
             }
             
             using (ZipFile zip2 = ZipFile.Read("Content.zip"))
             {
               zip2.UpdateFile("Updates\\Readme.txt", "");
               zip2.Comment = "This zip archive has been updated.";
               zip2.Save();
             }
            
             </code>
             <code lang="VB">
               Using zip1 As New ZipFile
                   zip1.UpdateFile("MyDocuments\Readme.txt", "")
                   zip1.Comment = "This zip archive has been created."
                   zip1.Save("Content.zip")
               End Using
            
               Using zip2 As ZipFile = ZipFile.Read("Content.zip")
                   zip2.UpdateFile("Updates\Readme.txt", "")
                   zip2.Comment = "This zip archive has been updated."
                   zip2.Save
               End Using
             </code>
             </example>
            
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.AddFile(System.String)"/>
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.UpdateDirectory(System.String)"/>
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.UpdateItem(System.String)"/>
            
             <param name="FileName">
             The name of the file to add or update. It should refer to a file in the filesystem.  
             The name of the file may be a relative path or a fully-qualified path. 
             </param>
            
             <returns>The ZipEntry corresponding to the File that was added or updated.</returns>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.UpdateFile(System.String,System.String)">
             <summary>
             Adds or Updates a File in a Zip file archive.
             </summary>
             
             <remarks>
             <para>
             This method adds a file to a zip archive, or, if the file already exists in the zip archive, 
             this method Updates the content of that given filename in the zip archive.
             </para>
             
             <para>
             This version of the method allows the caller to explicitly specify the 
             directory path to be used in the archive.  The entry to be added or updated is found by 
             using the specified directory path, combined with the basename of the specified 
             filename. 
             </para>
             
             <para>
             Upon success, there is no way for the application to learn whether the file was added or updated. 
             </para>
             </remarks>
             
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.AddFile(System.String,System.String)"/>
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.UpdateDirectory(System.String,System.String)"/>
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.UpdateItem(System.String,System.String)"/>
            
             <param name="FileName">
             The name of the file to add or update. It should refer to a file in the filesystem.  
             The name of the file may be a relative path or a fully-qualified path. 
             </param>
            
             <param name="DirectoryPathInArchive">
             Specifies a directory path to use to override any path in the FileName.
             This path may, or may not, correspond to a real directory in the current filesystem.
             If the files within the zip are later extracted, this is the path used for the extracted file. 
             Passing null (nothing in VB) will use the path on the FileName, if any.  Passing the empty string ("")
             will insert the item at the root path within the archive. 
             </param>
            
             <returns>The ZipEntry corresponding to the File that was added or updated.</returns>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.UpdateDirectory(System.String)">
             <summary>
             Add or Update a Directory in a zip archive.
             If the directory has already been added to the archive,
             its contents are updated.  If not, then the directory is added.
             </summary>
            
             <remarks>
             If the specified directory does not exist in the archive, then this method is equivalent to
             calling AddDirectory().  If the specified directory already exists in the archive, then this 
             method updates any existing entries, and adds any new entries. Any entries that are in the 
             zip archive but not in the specified directory, are left alone.  In other words, the contents of 
             the zip file is a union of the previous contents and the new files.
             </remarks>
            
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.UpdateFile(System.String)"/>
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.AddDirectory(System.String)"/>
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.UpdateItem(System.String)"/>
            
             <param name="DirectoryName">The path to the directory to be added to the zip archive, 
             or updated in the zip archive.</param>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.UpdateDirectory(System.String,System.String)">
             <summary>
             Add or Update a directory in the zip archive at the specified root directory in the archive.  
             If the directory has already been added to the archive,
             its contents are updated.  If not, then the directory is added.
             </summary>
            
             <remarks>
             If the specified directory does not exist in the archive, then this method is equivalent to
             calling AddDirectory().  If the specified directory already exists in the archive, then this 
             method updates any existing entries, and adds any new entries. Any entries that are in the 
             zip archive but not in the specified directory, are left alone.  In other words, the contents of 
             the zip file is a union of the previous contents and the new files.
             </remarks>
            
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.UpdateFile(System.String,System.String)"/>
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.AddDirectory(System.String,System.String)"/>
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.UpdateItem(System.String,System.String)"/>
            
             <param name="DirectoryName">The path to the directory to be added to the zip archive, 
             or updated in the zip archive.</param>
            
             <param name="DirectoryPathInArchive">
             Specifies a directory path to use to override any path in the ItemName.
             This path may, or may not, correspond to a real directory in the current filesystem.
             If the files within the zip are later extracted, this is the path used for the extracted file. 
             Passing null (nothing in VB) will use the path on the FileName, if any.  Passing the empty string ("")
             will insert the item at the root path within the archive. 
             </param>
             
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.UpdateItem(System.String)">
             <summary>
             Add or Update a File or Directory in the zip archive. This
             is useful when the application is not sure or does not care
             if the entries in the existing zip archive already exist.
             </summary>
            
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.AddItem(System.String)"/>
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.UpdateFile(System.String)"/>
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.UpdateDirectory(System.String)"/>
            
             <param name="ItemName">the path to the file or directory to be added or updated.</param>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.UpdateItem(System.String,System.String)">
             <summary>
             Add or Update a File or Directory.  This is useful when the application is not sure or does not 
             care if the entries in the existing zip archive already exist.  
             </summary>
            
             <remarks>
             <para>
             This version of the method allows the caller to explicitly specify the 
             directory path to be used for the item being added to the archive.  The entry or entries 
             that are added or updated will use the specified <c>DirectoryPathInArchive</c>. Extracting
             the entry from the archive will result in a file stored in that directory path. 
             </para>
             </remarks>
            
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.AddItem(System.String,System.String)"/>
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.UpdateFile(System.String,System.String)"/>
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.UpdateDirectory(System.String,System.String)"/>
            
             <param name="ItemName">The path for the File or Directory to be added or updated.</param>
             <param name="DirectoryPathInArchive">
             Specifies a directory path to use to override any path in the ItemName.
             This path may, or may not, correspond to a real directory in the current filesystem.
             If the files within the zip are later extracted, this is the path used for the extracted file. 
             Passing null (nothing in VB) will use the path on the FileName, if any.  Passing the empty string ("")
             will insert the item at the root path within the archive. 
             </param>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.AddFileStream(System.String,System.String,System.IO.Stream)">
             <summary>
             Uses the given stream as input to create an entry in the ZipFile, with the 
             given FileName and given Directory Path.  Encryption will be used on the 
             stream data if the Password is set on the ZipFile object, prior to calling
             this method.
             </summary>
             <remarks>
             The stream must remain open and readable at least through the call to 
             <c>ZipFile.Save()</c>.
             </remarks>
            
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.UpdateFileStream(System.String,System.String,System.IO.Stream)"/>
            
             <param name="FileName">FileName which is shown in the ZIP File</param>
             <param name="DirectoryPathInArchive">
             Specifies a directory path to use to override any path in the ItemName.
             This path may, or may not, correspond to a real directory in the current filesystem.
             If the files within the zip are later extracted, this is the path used for the extracted file. 
             Passing null (nothing in VB) will use the path on the FileName, if any.  Passing the empty string ("")
             will insert the item at the root path within the archive. 
             </param>
             <param name="stream">the input stream from which to grab content for the file</param>
             <returns>The ZipEntry added.</returns>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.AddStringAsFile(System.String,System.String,System.String)">
            <summary>
            Adds an entry into the zip archive using the given filename and directory path within the archive,
            and the given content for the file.  No file is created in the filesystem.  
            </summary>
            <param name="Content">The content of the file, should it be extracted from the zip.</param>
            <param name="FileName">The filename to use within the archive.</param>
            <param name="DirectoryPathInArchive">
            Specifies a directory path to use to override any path in the ItemName.
            This path may, or may not, correspond to a real directory in the current filesystem.
            If the files within the zip are later extracted, this is the path used for the extracted file. 
            Passing null (nothing in VB) will use the path on the FileName, if any.  Passing the empty string ("")
            will insert the item at the root path within the archive. 
            </param>
            <returns>The ZipEntry added.</returns>
            
            <example>
            This example shows how to add an entry to the zipfile, using a string as content for that entry. 
            <code>
            string Content = "This string will be the content of the Readme.txt file in the zip archive.";
            using (ZipFile zip1 = new ZipFile())
            {
              zip1.AddFile("MyDocuments\\Resume.doc", "files");
              zip1.AddStringAsFile(Content, "Readme.txt", ""); 
              zip1.Comment = "This zip file was created at " + System.DateTime.Now.ToString("G");
              zip1.Save("Content.zip");
            }
            
            </code>
            </example>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.UpdateFileStream(System.String,System.String,System.IO.Stream)">
             <summary>
             Updates the given entry in the zipFile, using the given stream as input, and the
             given FileName and given Directory Path.  Encryption will be used on the 
             stream data if the Password is set on the ZipFile object, prior to calling
             this method.
             </summary>
            
             <remarks>
             The stream must remain open and readable at least through the call to 
             <c>ZipFile.Save()</c>.
             </remarks>
            
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.AddFileStream(System.String,System.String,System.IO.Stream)"/>
            
             <param name="FileName">FileName which is shown in the ZIP File</param>
             <param name="DirectoryPathInArchive">The root path to be used in the ZIP archive, 
             for the entry added from the stream.</param>
             <param name="stream">The Input Stream to read file data from.</param>
             <returns>The ZipEntry added.</returns>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.AddDirectory(System.String)">
             <summary>
             Adds a Directory to a Zip file archive. 
             </summary>
             
             <remarks>
             The name of the directory may be 
             a relative path or a fully-qualified path. The add operation is recursive,
             so that any files or subdirectories within the name directory are also
             added to the archive.
             </remarks>
             
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.AddItem(System.String)"/>
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.AddFile(System.String)"/>
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.UpdateDirectory(System.String)"/>
            
             <overloads>This method has 2 overloads.</overloads>
             
             <param name="DirectoryName">The name of the directory to add.</param>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.AddDirectory(System.String,System.String)">
             <summary>
             Adds a Directory to a Zip file archive, overriding the path to be 
             used in the archive. 
             </summary>
             
             <remarks>
             The name of the directory may be 
             a relative path or a fully-qualified path. The add operation is recursive,
             so that any files or subdirectories within the name directory are also
             added to the archive.
             </remarks>
             
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.AddItem(System.String,System.String)"/>
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.AddFile(System.String,System.String)"/>
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.UpdateDirectory(System.String,System.String)"/>
            
             <param name="DirectoryName">The name of the directory to add.</param>
             
             <param name="DirectoryPathInArchive">
             Specifies a directory path to use to override any path in the DirectoryName.
             This path may, or may not, correspond to a real directory in the current filesystem.
             If the zip is later extracted, this is the path used for the extracted file or directory. 
             Passing null (nothing in VB) will use the path on the DirectoryName. Passing the empty string ("")
             will insert the item at the root path within the archive. 
             </param>
             
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.Save">
             <summary>
             Saves the Zip archive, using the name given when the ZipFile was instantiated. 
             </summary>
             <remarks>
             <para>
             The zip file is written to storage only when the caller calls <c>Save()</c>.  
             The Save operation writes the zip content to a temporary file. 
             Then, if the zip file already exists (for example when adding an item to a zip archive)
             this method will replace the existing zip file with this temporary file.
             If the zip file does not already exist, the temporary file is renamed 
             to the desired name.  
             </para>
            
             <para>
             When using the zip library within an ASP.NET application, you may wish to set the
             TempFileFolder on the ZipFile instance before calling Save().
             </para>
             </remarks>
            
             <exception cref="T:Ionic.Utils.Zip.BadStateException">
             Thrown if you haven't specified a location or stream for saving the zip,
             either in the constructor or by setting the Name property. 
             </exception>
            
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.Save(System.String)">
             <summary>
             Save the file to a new zipfile, with the given name. 
             </summary>
             
             <remarks>
             <para>
             This is handy when reading a zip archive from a stream 
             and you want to modify the archive (add a file, change a 
             comment, etc) and then save it to a file. 
             </para>
             <para>
             It also works if you create a new ZipFile for writing to a 
             stream, and then you also want to write it to a filesystem file. 
             In that case, call the Save() method, and then also call this method with
             a filename. 
             </para>
             </remarks>
             
             <exception cref="T:System.ArgumentException">
             Thrown if you specify a directory for the filename.
             </exception>
            
             <param name="ZipFileName">
             The name of the zip archive to save to. Existing files will 
             be overwritten with great prejudice.
             </param>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.OnSaveProgress(Ionic.Utils.Zip.SaveProgressEventArgs)">
            <summary>
            Fires the <see cref="E:Ionic.Utils.Zip.ZipFile.SaveProgress"/> method.
            </summary>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.OnSaveCompleted(Ionic.Utils.Zip.SaveEventArgs)">
            <summary>
            Fires the <see cref="E:Ionic.Utils.Zip.ZipFile.SaveCompleted"/> method.
            </summary>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.OnSaveStarted(Ionic.Utils.Zip.SaveEventArgs)">
            <summary>
            Fires the <see cref="E:Ionic.Utils.Zip.ZipFile.SaveStarted"/> method.
            </summary>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.Read(System.String)">
             <summary>
             Reads a zip file archive and returns the instance.  
             </summary>
             
             <exception cref="T:System.Exception">
             Thrown if the zipfile cannot be read. The implementation of this 
             method relies on <c>System.IO.File.OpenRead()</c>, which can throw
             a variety of exceptions, including specific exceptions if a file
             is not found, an unauthorized access exception, exceptions for
             poorly formatted filenames, and so on. 
             </exception>
             
             <param name="ZipFileName">
             The name of the zip archive to open.  
             This can be a fully-qualified or relative pathname.
             </param>
             
             <overloads>If I am counting correctly, this method has 6 overloads.</overloads>
            
             <returns>The instance read from the zip archive.</returns>
             
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.Read(System.String,System.IO.TextWriter)">
             <summary>
             Reads a zip file archive and returns the instance.  
             </summary>
             
             <remarks>
             <para>
             This version of the method allows the caller to pass in a TextWriter, to which verbose 
             messages will be written during extraction or creation of the zip archive.  A console application
             may wish to pass System.Console.Out to get messages on the Console. A graphical or headless application
             may wish to capture the messages in a different TextWriter. 
             </para>
             </remarks>
             
             <example>
             <code>
             var sw = new System.IO.StringWriter();
             using (ZipFile zip =  ZipFile.Read("PackedDocuments.zip", sw))
             {
               var Threshold = new DateTime(2007,7,4);
               // We cannot remove the entry from the list, within the context of 
               // an enumeration of said list.
               // So we add the doomed entry to a list to be removed later.
               // pass 1: mark the entries for removal
               var MarkedEntries = new System.Collections.Generic.List&lt;ZipEntry&gt;();
               foreach (ZipEntry e in zip)
               {
                 if (e.LastModified &lt; Threshold)
                   MarkedEntries.Add(e);
               }
               // pass 2: actually remove the entry. 
               foreach (ZipEntry zombie in MarkedEntries)
                  zip.RemoveEntry(zombie);
               zip.Comment = "This archive has been updated.";
               zip.Save();
             }
             // can now use contents of sw, eg store in the audit log
             </code>
            
             <code lang="VB">
               Dim sw As New System.IO.StringWriter
               Using zip As ZipFile = ZipFile.Read("PackedDocuments.zip", sw)
                   Dim Threshold As New DateTime(2007, 7, 4)
                   ' We cannot remove the entry from the list, within the context of 
                   ' an enumeration of said list.
                   ' So we add the doomed entry to a list to be removed later.
                   ' pass 1: mark the entries for removal
                   Dim MarkedEntries As New System.Collections.Generic.List(Of ZipEntry)
                   Dim e As ZipEntry
                   For Each e In zip
                       If (e.LastModified &lt; Threshold) Then
                           MarkedEntries.Add(e)
                       End If
                   Next
                   ' pass 2: actually remove the entry. 
                   Dim zombie As ZipEntry
                   For Each zombie In MarkedEntries
                       zip.RemoveEntry(zombie)
                   Next
                   zip.Comment = "This archive has been updated."
                   zip.Save
               End Using
               ' can now use contents of sw, eg store in the audit log
             </code>
             </example>
             <exception cref="T:System.Exception">
             Thrown if the zipfile cannot be read. The implementation of this 
             method relies on <c>System.IO.File.OpenRead()</c>, which can throw
             a variety of exceptions, including specific exceptions if a file
             is not found, an unauthorized access exception, exceptions for
             poorly formatted filenames, and so on. 
             </exception>
             
             <param name="ZipFileName">
             The name of the zip archive to open.  
             This can be a fully-qualified or relative pathname.
             </param>
             
             <param name="StatusMessageWriter">
             The <c>System.IO.TextWriter</c> to use for writing verbose status messages.
             </param>
             
             <returns>The instance read from the zip archive.</returns>
             
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.Read(System.IO.Stream)">
             <summary>
             Reads a zip archive from a stream.
             </summary>
            
             <remarks>
             <para>
             This is useful when when the zip archive content is available from 
             an already-open stream. The stream must be open and readable when calling this
             method.  The stream is left open when the reading is completed. 
             </para>
             </remarks>
            
             <example>
             This example shows how to Read zip content from a stream, and extract
             one entry into a different stream. In this example, the filename
             "NameOfEntryInArchive.doc", refers only to the name of the entry
             within the zip archive.  A file by that name is not created in the
             filesystem.  The I/O is done strictly with the given streams.
             <code>
             using (ZipFile zip = ZipFile.Read(InputStream))
             {
               zip.Extract("NameOfEntryInArchive.doc", OutputStream);
             }
             </code>
             <code lang="VB">
             Using zip as ZipFile = ZipFile.Read(InputStream)
               zip.Extract("NameOfEntryInArchive.doc", OutputStream)
             End Using
             </code>
             </example>
            
             <param name="InputZipStream">the stream containing the zip data.</param>
             <returns>an instance of ZipFile</returns>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.Read(System.IO.Stream,System.IO.TextWriter)">
            <summary>
            Reads a zip archive from a stream.
            </summary>
            <remarks>
            <para>
            This is useful when when the zip archive content is available from 
            an already-open stream. The stream must be open and readable when calling this
            method.  The stream is left open when the reading is completed. 
            </para>
            <para>
            This overload allows the caller to specify a TextWriter to which 
            Verbose messages are sent. For example, in a console application, System.Console.Out 
            works. If the TextWriter is null, no verbose messages are written. 
            </para>
            </remarks>
            <param name="ZipStream">the stream containing the zip data.</param>
            <param name="StatusMessageWriter">The <c>System.IO.TextWriter</c> to which verbose status messages are written.</param>
            <returns>an instance of ZipFile</returns>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.Read(System.Byte[])">
            <summary>
            Reads a zip archive from a byte array.
            </summary>
            
            <remarks>
            This is useful when the data for the zipfile is contained in a byte array, 
            for example, downloaded from an FTP server without being saved to a
            filesystem. 
            </remarks>
            
            <param name="buffer">
            The byte array containing the zip data.  
            (I don't know why, but sometimes the compiled helpfuile (.chm) indicates a 2d 
            array when it is just one-dimensional.  This is a one-dimensional array.)
            </param>
            
            <returns>an instance of ZipFile. The name on the ZipFile will be null (nothing in VB)). </returns>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.Read(System.Byte[],System.IO.TextWriter)">
            <summary>
            Reads a zip archive from a byte array, using the given StatusMessageWriter.
            </summary>
            
            <remarks>
            <para>
            This method is useful when the data for the zipfile is contained in a byte array, for
            example when retrieving the data from a database or other non-filesystem store.
            </para>
            
            <para>
            This overload allows the caller to specify a <c>TextWriter</c> to which Verbose
            messages are sent. For example, in a console application, <c>System.Console.Out</c>
            works. If the TextWriter is null, no verbose messages are written.
            </para>
            </remarks>
            
            <param name="buffer">the byte array containing the zip data.</param>
            <param name="StatusMessageWriter">
            The <c>System.IO.TextWriter</c> to which verbose status messages are written.
            </param>
            
            <returns>an instance of ZipFile. The name is set to null.</returns>
            
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.GetEnumerator">
             <summary>
             Generic IEnumerator support, for use of a ZipFile in a foreach construct.  
             </summary>
             <remarks>
             You probably do not want to call <c>GetEnumerator</c> explicitly. Instead 
             it is implicitly called when you use a <c>foreach</c> loop in C#, or a 
             <c>For Each</c> loop in VB.
             </remarks>
             <example>
             This example reads a zipfile of a given name, then enumerates the 
             entries in that zip file, and displays the information about each 
             entry on the Console.
             <code>
             using (ZipFile zip = ZipFile.Read(zipfile))
             {
               bool header = true;
               foreach (ZipEntry e in zip)
               {
                 if (header)
                 {
                    System.Console.WriteLine("Zipfile: {0}", zip.Name);
                    System.Console.WriteLine("Version Needed: 0x{0:X2}", e.VersionNeeded);
                    System.Console.WriteLine("BitField: 0x{0:X2}", e.BitField);
                    System.Console.WriteLine("Compression Method: 0x{0:X2}", e.CompressionMethod);
                    System.Console.WriteLine("\n{1,-22} {2,-6} {3,4}   {4,-8}  {0}",
                                 "Filename", "Modified", "Size", "Ratio", "Packed");
                    System.Console.WriteLine(new System.String('-', 72));
                    header = false;
                 }
            
                 System.Console.WriteLine("{1,-22} {2,-6} {3,4:F0}%   {4,-8}  {0}",
                             e.FileName,
                             e.LastModified.ToString("yyyy-MM-dd HH:mm:ss"),
                             e.UncompressedSize,
                             e.CompressionRatio,
                             e.CompressedSize);
            
                 e.Extract();
               }
             }
             </code>
            
             <code lang="VB">
               Dim ZipFileToExtract As String = "c:\foo.zip"
               Using zip As ZipFile = ZipFile.Read(ZipFileToExtract)
                   Dim header As Boolean = True
                   Dim e As ZipEntry
                   For Each e In zip
                       If header Then
                           Console.WriteLine("Zipfile: {0}", zip.Name)
                           Console.WriteLine("Version Needed: 0x{0:X2}", e.VersionNeeded)
                           Console.WriteLine("BitField: 0x{0:X2}", e.BitField)
                           Console.WriteLine("Compression Method: 0x{0:X2}", e.CompressionMethod)
                           Console.WriteLine(ChrW(10) &amp; "{1,-22} {2,-6} {3,4}   {4,-8}  {0}", _
                             "Filename", "Modified", "Size", "Ratio", "Packed" )
                           Console.WriteLine(New String("-"c, 72))
                           header = False
                       End If
                       Console.WriteLine("{1,-22} {2,-6} {3,4:F0}%   {4,-8}  {0}", _
                         e.FileName, _
                         e.LastModified.ToString("yyyy-MM-dd HH:mm:ss"), _
                         e.UncompressedSize, _
                         e.CompressionRatio, _
                         e.CompressedSize )
                       e.Extract
                   Next
               End Using
             </code>
             </example>
             
             <returns>a generic enumerator suitable for use  within a foreach loop.</returns>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            IEnumerator support, for use of a ZipFile in a foreach construct.  
            </summary>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.ExtractAll(System.String)">
             <summary>
             Extracts all of the items in the zip archive, to the specified path in the filesystem.
             The path can be relative or fully-qualified. 
             </summary>
            
             <remarks>
             <para>
             If an extraction of a file from the zip archive would overwrite an existing file
             in the filesystem, the file will not be overwritten and an exception will be
             thrown. To avoid this, use the overload that allows you to specify that you want
             to overwrite existing files.
             </para>
            
             <para>
             This method will send verbose output messages to the StatusMessageTextWriter, if it 
             is set on the ZipFile instance. 
             </para>
             </remarks>
            
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.ExtractAll(System.String,System.Boolean)"/>
            
             <param name="path">The path to which the contents of the zip archive should be extracted.</param>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.ExtractAll(System.String,System.Boolean)">
             <summary>
             Extracts all of the items in the zip archive, to the specified path in the filesystem,  
             optionally overwriting any existing files. The path can be relative or fully-qualified. 
             </summary>
            
             <remarks>
             This method will send verbose output messages to the StatusMessageTextWriter, if it 
             is set on the ZipFile instance. 
             </remarks>
            
             <example>
             This example extracts all the entries in a zip archive file, 
             to the specified target directory.  It overwrites any existing files.
             It also handles exceptions that may be thrown, such as unauthorized 
             access exceptions.
             <code>
             String TargetDirectory= "c:\\temp\\unpack";
             try 
             {
               using(ZipFile zip= ZipFile.Read(ZipFileToExtract))
               {
                 zip.ExtractAll(TargetDirectory, true);
               }
             }
             catch (System.Exception ex1)
             {
               System.Console.Error.WriteLine("exception: {0}", ex1);
             }
             </code>
             
             <code lang="VB">
               Dim TargetDirectory As String = "c:\temp\unpack"
               Try 
                   Using zip As ZipFile = ZipFile.Read(ZipFileToExtract)
                       zip.ExtractAll(TargetDirectory, True)
                   End Using
               Catch ex1 As Exception
                   Console.Error.WriteLine("exception: {0}", ex1.ToString)
               End Try
             </code>
             </example>
             
             <param name="path">the path to which the contents of the zipfile are extracted.</param>
             <param name="WantOverwrite">true to overwrite any existing files on extraction</param>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.Extract(System.String)">
            <summary>
            Extract a single item from the archive.  The file, including any relative
            qualifying path, is created at the current working directory.  
            </summary>
            <param name="FileName">the file to extract. It must be the exact filename, including the path contained in the archive, if any. </param>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.Extract(System.String,System.String)">
            <summary>
            Extract a single item from the archive.  The file, including any relative
            qualifying path, is created at the current working directory.  
            </summary>
            <param name="FileName">the file to extract. It must be the exact filename, including the path contained in the archive, if any. </param>
            <param name="DirectoryName">the directory into which to extract. It should exist.</param>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.Extract(System.String,System.Boolean)">
            <summary>
            Extract a single item from the archive, potentially overwriting  
            any existing file in the filesystem by the same name. The file, including any relative 
            qualifying path, is created at the current working directory.  
            </summary>
            <param name="filename">
            The file to extract. It must be the exact filename, including the path contained in the 
            archive, if any. The pathname can use forward-slashes or backward slashes.
            </param>
            <param name="WantOverwrite">True if the caller wants to overwrite any existing files by the given name.</param>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.Extract(System.String,System.String,System.Boolean)">
            <summary>
            Extract a single item from the archive, into the specified directory, potentially overwriting  
            any existing file in the filesystem by the same name. The file, including any relative 
            qualifying path, is created in the specified directory.  
            </summary>
            <param name="FileName">
            The file to extract. It must be the exact filename, including the path contained in the archive, 
            if any. The pathname can use forward-slashes or backward slashes.
            </param>
            <param name="DirectoryName">the directory into which to extract. It should exist.</param>
            <param name="WantOverwrite">True if the caller wants to overwrite any existing files by the given name.</param>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.Extract(System.String,System.IO.Stream)">
            <summary>
            Extract a single specified file from the archive, to the given stream.  This is 
            useful when extracting to Console.Out or to a memory stream, for example. 
            </summary>
            <exception cref="T:System.ArgumentException">
            Thrown if the stream is not writable.  
            </exception>
            <param name="FileName">the file to extract. The application can specify pathnames using forward-slashes or backward slashes.</param>
            <param name="OutputStream">the stream to which the extacted, decompressed file data is written. The stream must be writable.</param>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.RemoveEntry(Ionic.Utils.Zip.ZipEntry)">
             <summary>
             Removes the given ZipEntry from the zip archive.  
             </summary>
             
             <remarks>
             <para>
             After calling <c>RemoveEntry()</c>, the application must call <c>Save()</c> to make the changes permanent.  
             </para>
             </remarks>
            
             <exception cref="T:System.ArgumentException">
             Thrown if the specified ZipEntry does not exist in the ZipFile.
             </exception>
            
             <example>
             In this example, all entries in the zip archive dating from before December 31st, 2007, are
             removed from the archive.
             <code>
             System.DateTime Threshold = new System.DateTime(2007,12,31);
             using (ZipFile zip = new ZipFile(ZipFileToRead))
             {
               var EntriesToRemove = new System.Collections.Generic.List&lt;ZipEntry&gt;();
               foreach (ZipEntry e in zip)
               {
                 if (e.LastModified &lt; Threshold)
                 {
                   // We cannot remove the entry from the list, within the context of 
                   // an enumeration of said list.
                   // So we add the doomed entry to a list to be removed later.
                   EntriesToRemove.Add(e);
                 }
               }
               
               // actually remove the doomed entries. 
               foreach (ZipEntry zombie in EntriesToRemove)
                 zip.RemoveEntry(zombie);
               
               zip.Comment= String.Format("This zip archive was updated at {0}.", 
                                          System.DateTime.Now.ToString("G"));
               zip.Save();
             }
             </code>
             
             <code lang="VB">
               Dim ZipFileToRead As String = "c:\foo.zip"
               Dim Threshold As New DateTime(2007, 12, 31)
               Using zip As ZipFile = New ZipFile(ZipFileToRead)
                   Dim EntriesToRemove As New System.Collections.Generic.List(Of ZipEntry)
                   Dim e As ZipEntry
                   For Each e In zip
                       If (e.LastModified &lt; Threshold) Then
                           ' We cannot remove the entry from the list, within the context of 
                           ' an enumeration of said list.
                           ' So we add the doomed entry to a list to be removed later.
                           EntriesToRemove.Add(e)
                       End If
                   Next
               
                   ' actually remove the doomed entries. 
                   Dim zombie As ZipEntry
                   For Each zombie In EntriesToRemove
                       zip.RemoveEntry(zombie)
                   Next
                   zip.Comment = String.Format("This zip archive was updated at {0}.", DateTime.Now.ToString("G"))
                   zip.Save
               End Using
             </code>
             </example>
             
             <param name="entry">
             The ZipEntry to remove from the zip. 
             </param>
             
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.RemoveEntry(System.String)">
             <summary>
             Removes the ZipEntry with the given filename from the zip archive.  
             </summary>
             
             <remarks>
             <para>
             After calling <c>RemoveEntry()</c>, the application must call <c>Save()</c> to make the changes permanent.  
             </para>
            
             </remarks>
            
             <exception cref="T:System.InvalidOperationException">
             Thrown if the ZipFile is not updatable. 
             </exception>
            
             <exception cref="T:System.ArgumentException">
             Thrown if a ZipEntry with the specified filename does not exist in the ZipFile.
             </exception>
            
             <example>
             This example shows one way to remove an entry with a given filename from an 
             existing zip archive.
             <code>
             String ZipFileToRead= "PackedDocuments.zip";
             string Candidate = "DatedMaterial.xps";
             using (ZipFile zip = new ZipFile(ZipFileToRead))
             {
               if (zip.EntryFilenames.Contains(Candidate))
               {
                 zip.RemoveEntry(Candidate);
                 zip.Comment= String.Format("The file '{0}' has been removed from this archive.", 
                                            Candidate);
                 zip.Save();
               }
             }
             </code>
             <code lang="VB">
               Dim ZipFileToRead As String = "PackedDocuments.zip"
               Dim Candidate As String = "DatedMaterial.xps"
               Using zip As ZipFile = New ZipFile(ZipFileToRead)
                   If zip.EntryFilenames.Contains(Candidate) Then
                       zip.RemoveEntry(Candidate)
                       zip.Comment = String.Format("The file '{0}' has been removed from this archive.", Candidate)
                       zip.Save
                   End If
               End Using
             </code>
             </example>
             
             <param name="FileName">
             The name of the file, including any directory path, to remove from the zip. The
             pathname can use forward-slashes or backward slashes.
             </param>
             
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.Finalize">
            <summary>
            This is the class Destructor, which gets called implicitly when the instance is destroyed.  
            Because the ZipFile type implements IDisposable, this method calls Dispose(false).  
            </summary>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.Dispose">
            <summary>
            Handles closing of the read and write streams associated
            to the ZipFile, if necessary.  The Dispose() method is generally 
            employed implicitly, via a using() {} statement. 
            </summary>
            <example>
            <code>
            using (ZipFile zip = ZipFile.Read(zipfile))
            {
              foreach (ZipEntry e in zip)
              {
                if (WantThisEntry(e.FileName)) 
                  zip.Extract(e.FileName, Console.OpenStandardOutput());
              }
            } // Dispose() is called implicitly here.
            </code>
            </example>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.Dispose(System.Boolean)">
            <summary>
            The Dispose() method.  It disposes any managed resources, 
            if the flag is set, then marks the instance disposed.
            This method is typically not called from application code.
            </summary>
            <param name="disposeManagedResources">indicates whether the method should dispose streams or not.</param>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipFile.Name">
            <summary>
            This read-only property specifies the name of the zipfile to read or write. It is 
            set when the instance of the ZipFile type is created. When instantiating a ZipFile 
            to read from or write to a stream, the Name property remains null.
            </summary>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipFile.Comment">
             <summary>
             A comment attached to the zip archive.
             </summary>
            
             <remarks>
             <para>
             This property is read/write for the zipfile. It allows the application to
             specify a comment for the zipfile, or read the comment for the zipfile. 
             If setting the comment, changes are only made permanent when you call a
             <c>Save()</c> method.
             </para>
             <para>
             According to the zip spec, the comment is not encrypted, even if there is a password
             set on the zip archive. But you knew that...
             </para>
             </remarks>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipFile.TrimVolumeFromFullyQualifiedPaths">
             <summary>
             When this is set, any volume name (eg C:) is trimmed 
             from fully-qualified pathnames on any ZipEntry, before writing the 
             ZipEntry into the ZipFile. 
             </summary>
            
             <remarks>
             <para>
             The default value is true. This setting must be true to allow 
             Windows Explorer to read the zip archives properly. It's also required to be 
             true if you want to read the generated zip files on any other non-Windows OS. 
             </para>
             
             <para>
             The property is included for backwards compatibility only.  You'll 
             almost never need or want to set this to false.
             </para>
             </remarks>
            
        </member>
        <member name="P:Ionic.Utils.Zip.ZipFile.Verbose">
            <summary>
            Indicates whether verbose output is sent to Output 
            during <c>AddXxx()</c> and <c>ReadXxx()</c> operations. 
            </summary>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipFile.StatusMessageTextWriter">
             <summary>
             Gets or sets the <c>TextWriter</c> to which status messages are delivered 
             for the instance. If the TextWriter is set to a non-null value, then 
             verbose output is sent to the <c>TextWriter</c> during <c>Add</c><c>, Read</c><c>, Save</c> and
             <c>Extract</c> operations.  
             </summary>
            
             <example>
             <para>
             In this example, a console application instantiates a ZipFile, then sets
             the StatusMessageTextWriter to Console.Out.  At that point, all verbose
             status messages for that ZipFile are sent to the console. 
             </para>
            
             <code>
             using (ZipFile zip= new ZipFile(FilePath))
             {
               zip.StatusMessageTextWriter= System.Console.Out;
               // messages are sent to the console during extraction
               zip.ExtractAll();
             }
             </code>
            
             <code lang="VB">
             Using zip As new ZipFile(FilePath)
               zip.StatusMessageTextWriter= System.Console.Out
               'Status Messages will be sent to the console during extraction
               zip.ExtractAll()
             End Using
             </code>
             </example>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipFile.ForceNoCompression">
             <summary>
             Gets or sets the flag that indicates whether the ZipFile should use
             compression for subsequently added entries in the ZipFile instance.
             </summary>
            
             <remarks>
             There is logic in the DotNetZip library that compares the size of the pre-compressed
             data with the size of the post-compressed data, and uses compression only if the size 
             is smaller. For file types that are known to be compressed, like MP3's or JPGs, this 
             would waste clock cycles. In these cases it would be nice to allow the app to explicitly 
             request that Compression not be used.  That's what this flag does.  The default value 
             is false. You can also set the CompressionMethod property on the ZipEntry, for 
             more granular control of this capability.  
             </remarks>
            
             <seealso cref="P:Ionic.Utils.Zip.ZipEntry.CompressionMethod"/>
            
             <example>
             This example shows how to specify that Compression will not be used when adding files 
             to the zip archive. None of the files added to the archive in this way will use
             compression.
             <code>
             using (ZipFile zip = new ZipFile(ZipFileToCreate))
             {
               zip.ForceNoCompression = true;
               zip.AddDirectory(@"c:\temp\Foo");
               zip.Comment = "All files in this archive will be uncompressed.";
               zip.Save();
             }
             </code>
            
             <code lang="VB">
             Using zip As New ZipFile(ZipFileToCreate)
               zip.ForceNoCompression = true
               zip.AddDirectory("c:\temp\Foo")
               zip.Comment = "All files in this archive will be uncompressed."
               zip.Save()
             End Using
             </code>
            
             </example>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipFile.TempFileFolder">
             <summary>
             Gets or sets the name for the folder to store the temporary file
             this library writes when saving the zip archive. 
             </summary>
            
             <remarks>
             The calling application should have write and delete rights on that folder.  By
             default, the temp file folder is the directory referred to by the TEMP
             environment variable.  If that variable is not set, this value defaults to the
             current working directory.  But for some scenarios, such as ASP.NET
             applications, the application may wish to explicitly override this,
             with this public property. This property is used only when calling one of the
             <c>Save()</c> methods, or the <c>SaveSelfExtractor()</c> method.
             </remarks>
            
             <exception cref="T:System.IO.FileNotFoundException">
             Thrown upon setting the property if the directory does not exist. 
             </exception>
            
        </member>
        <member name="P:Ionic.Utils.Zip.ZipFile.Password">
             <summary>
             Sets the password to be used for any entry subsequently added 
             to the zip archive.  This password is applied to the entries, not
             to the zip archive itself. 
             </summary>
             <remarks>
             <para>Though the password is set on the ZipFile object, the password actually does 
             not apply to the archive as a whole.  Instead, it applies to individual entries 
             that are added to the archive. The "directory" of the archive - in other words 
             the list of files - is not encrypted with the password. Instead the contents of 
             the individual files are encrypted.  The list of filenames in the archive is in clear 
             text.
             </para><para>
             If you set the password on the zip archive, and then add a set of files to the 
             archive, then each entry is encrypted with that password.  You may also want 
             to change the password between adding different entries. If you set the 
             password, add an entry, then set the password to null, and add another entry,
             the first entry is encrypted and the second is not.  Furshtay?
             </para>
             </remarks>
            
             <example>
             <para>
             In this example, three files are added to a Zip archive. The ReadMe.txt file
             will be placed in the root of the archive, and will not be encrypted. 
             The .png file will be included into the zip, encrypted with the "123456!" password.
             The pdf file will be included, encrypted with "!Secret1" as the password.
             </para>
             <code>
                try
                {
                  using (ZipFile zip = new ZipFile("test3.zip",System.Console.Out))
                  {
                    zip.AddFile("ReadMe.txt");
                    zip.Password= "123456!";
                    zip.AddFile("7440-N49th.png");
                    zip.Password= "!Secret1";
                    zip.AddFile("2005_Annual_Report.pdf");
            
                    zip.Save();
                  }
                }
                catch (System.Exception ex1)
                {
                  System.Console.Error.WriteLine("exception: {0}", ex1);
                }
             </code>
            
             <code lang="VB">
              Try 
                Using zip As New ZipFile("test2.zip", System.Console.Out)
                  zip.AddFile("c:\datafiles\ReadMe.txt", "")
                  zip.Password = "123456!"
                  zip.AddFile("c:\photos\personal\7440-N49th.png", "images")
                  zip.Password= "!Secret1";
                  zip.AddFile("c:\Desktop\2005_Annual_Report.pdf", "files\documents")
                  zip.Save
                End Using
              Catch ex1 As System.Exception
                System.Console.Error.WriteLine("exception: {0}", ex1)
              End Try
             </code>
            
             </example>
             
        </member>
        <member name="E:Ionic.Utils.Zip.ZipFile.SaveProgress">
             <summary>
             Fired after each entry has been written to the archive.
             </summary>
             <example>
             <code>
             public static void SaveProgress(object sender, SaveProgressEventArgs e)
             {
               Console.WriteLine("{0} ({1}/{2})", e.NameOfLatestEntry, e.EntriesSaved, e.EntriesTotal);
             }
             
             public static ZipUp(string targetZip, string directory)
             {
               using (var zip = new ZipFile()) {
                 zip.SaveProgress += SaveProgress; 
                 zip.AddDirectory(directory);
                 zip.Save(targetZip);
               }
             }
            
             </code>
             </example>
        </member>
        <member name="E:Ionic.Utils.Zip.ZipFile.SaveStarted">
            <summary>
            Fired when the save starts.
            </summary>
        </member>
        <member name="E:Ionic.Utils.Zip.ZipFile.SaveCompleted">
            <summary>
            Fired after the save completes.
            </summary>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipFile.Item(System.String)">
             <summary>
             This is a name-based indexer into the Zip archive.  
             </summary>
             
             <remarks>
             <para>
             This property is read-write. When setting the value, the
             only legal value is null. If you assign a non-null value
             (non Nothing in VB), the setter will throw an exception.
             </para>
             <para>
             Setting the value to null is equivalent to calling <c>ZipFile.Remove()</c> with the filename.
             </para>
             </remarks>
             
             <example>
             This example extracts only the entries in a zip file that are .txt files.
             <code>
             using (ZipFile zip = ZipFile.Read("PackedDocuments.zip"))
             {
               foreach (string s1 in zip.EntryFilenames)
               {
                 if (s1.EndsWith(".txt"))
                   zip[s1].Extract("textfiles");
               }
             }
             </code>
             <code lang="VB">
               Using zip As ZipFile = ZipFile.Read("PackedDocuments.zip")
                   Dim s1 As String
                   For Each s1 In zip.EntryFilenames
                       If s1.EndsWith(".txt") Then
                           zip(s1).Extract("textfiles")
                       End If
                   Next
               End Using
             </code>
             </example>
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.RemoveEntry(System.String)"/>
            
             <exception cref="T:System.ArgumentException">
             Thrown if the caller attempts to assign a non-null value to the indexer.
             </exception>
            
             <param name="FileName">
             The name of the file, including any directory path, to retrieve from the zip. The
             pathname can use forward-slashes or backward slashes.
             </param>
             
             <returns>
             The ZipEntry within the Zip archive, given by the specified filename. If the named
             entry does not exist in the archive, this indexer returns null.
             </returns>
             
        </member>
        <member name="P:Ionic.Utils.Zip.ZipFile.EntryFilenames">
             <summary>
             The list of filenames for the entries contained within the zip archive.  The 
             filenames use forward slashes in pathnames. 
             </summary>
            
             <seealso cref="P:Ionic.Utils.Zip.ZipFile.Item(System.String)"/>
            
             <example>
             This example shows one way to test if a filename is already contained within 
             a zip archive.
             <code>
             String ZipFileToRead= "PackedDocuments.zip";
             string Candidate = "DatedMaterial.xps";
             using (ZipFile zip = new ZipFile(ZipFileToRead))
             {
               if (zip.EntryFilenames.Contains(Candidate))
                 Console.WriteLine("The file '{0}' exists in the zip archive '{1}'",
                                   Candidate,
                                   ZipFileName);
               else
                 Console.WriteLine("The file, '{0}', does not exist in the zip archive '{1}'",
                                   Candidate,
                                   ZipFileName);
               Console.WriteLine();
             }
             </code>
             <code lang="VB">
               Dim ZipFileToRead As String = "PackedDocuments.zip"
               Dim Candidate As String = "DatedMaterial.xps"
               Using zip As New ZipFile(ZipFileToRead)
                   If zip.EntryFilenames.Contains(Candidate) Then
                       Console.WriteLine("The file '{0}' exists in the zip archive '{1}'", _
                                   Candidate, _
                                   ZipFileName)
                   Else
                     Console.WriteLine("The file, '{0}', does not exist in the zip archive '{1}'", _
                                   Candidate, _
                                   ZipFileName)
                   End If
                   Console.WriteLine
               End Using
             </code>
             </example>
            
             <returns>
             The list of strings for the filenames contained within the Zip archive.
             </returns>
             
        </member>
        <member name="T:Ionic.Utils.Zip.BadPasswordException">
            <summary>
            Issued when an <c>ZipEntry.ExtractWithPassword()</c> method is invoked
            with an incorrect password.
            </summary>
        </member>
        <member name="M:Ionic.Utils.Zip.BadPasswordException.#ctor">
            <summary>
            Default ctor.
            </summary>
        </member>
        <member name="M:Ionic.Utils.Zip.BadPasswordException.#ctor(System.String)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
        </member>
        <member name="T:Ionic.Utils.Zip.BadReadException">
            <summary>
            Indicates that a read was attempted on a stream, and bad or incomplete data was
            received.  
            </summary>
        </member>
        <member name="M:Ionic.Utils.Zip.BadReadException.#ctor">
            <summary>
            Default ctor.
            </summary>
        </member>
        <member name="M:Ionic.Utils.Zip.BadReadException.#ctor(System.String)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
        </member>
        <member name="T:Ionic.Utils.Zip.BadCrcException">
            <summary>
            Issued when an CRC check fails upon extracting an entry from a zip archive.
            </summary>
        </member>
        <member name="M:Ionic.Utils.Zip.BadCrcException.#ctor">
            <summary>
            Default ctor.
            </summary>
        </member>
        <member name="M:Ionic.Utils.Zip.BadCrcException.#ctor(System.String)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
        </member>
        <member name="T:Ionic.Utils.Zip.SfxGenerationException">
            <summary>
            Issued when errors occur saving a self-extracting archive.
            </summary>
        </member>
        <member name="M:Ionic.Utils.Zip.SfxGenerationException.#ctor">
            <summary>
            Default ctor.
            </summary>
        </member>
        <member name="M:Ionic.Utils.Zip.SfxGenerationException.#ctor(System.String)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
        </member>
        <member name="T:Ionic.Utils.Zip.BadStateException">
            <summary>
            Indicates that an operation was attempted on a ZipFile which was not possible
            given the state of the instance. For example, if you call <c>Save()</c> on a ZipFile 
            which has no filename set, you can get this exception. 
            </summary>
        </member>
        <member name="M:Ionic.Utils.Zip.BadStateException.#ctor">
            <summary>
            Default ctor.
            </summary>
        </member>
        <member name="M:Ionic.Utils.Zip.BadStateException.#ctor(System.String)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
        </member>
        <member name="T:Ionic.Utils.Zip.EncryptionAlgorithm">
            <summary>
            An enum that provides the various encryption algorithms supported by this library.
            </summary>
        </member>
        <member name="F:Ionic.Utils.Zip.EncryptionAlgorithm.None">
            <summary>
            No encryption at all.
            </summary>
        </member>
        <member name="F:Ionic.Utils.Zip.EncryptionAlgorithm.PkzipWeak">
            <summary>
            Traditional or Classic pkzip encryption.
            </summary>
        </member>
        <member name="T:Ionic.Utils.Zip.EntrySource">
            <summary>
            An enum that specifies the source of the ZipEntry. 
            </summary>
        </member>
        <member name="F:Ionic.Utils.Zip.EntrySource.None">
            <summary>
            Default value.  Invalid on a bonafide ZipEntry.
            </summary>
        </member>
        <member name="F:Ionic.Utils.Zip.EntrySource.Filesystem">
            <summary>
            Entry was instantiated by Adding an entry from the filesystem.
            </summary>
        </member>
        <member name="F:Ionic.Utils.Zip.EntrySource.Zipfile">
            <summary>
            Entry was instantiated by reading a zipfile.
            </summary>
        </member>
        <member name="T:Ionic.Utils.Zip.ZipEntry">
            <summary>
            Represents a single entry in a ZipFile. Typically, applications
            get a ZipEntry by enumerating the entries within a ZipFile,
            or by adding an entry to a ZipFile.  
            </summary>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipEntry.Read(System.IO.Stream)">
            <summary>
            Reads one ZipEntry from the given stream.  If the entry is encrypted, we don't
            actuall decrypt at this point. 
            </summary>
            <param name="s">the stream to read from.</param>
            <returns>the ZipEntry read from the stream.</returns>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipEntry.Extract">
             <summary>
             Extract the entry to the filesystem, starting at the current working directory. 
             </summary>
             
             <overloads>
             This method has a bunch of overloads! One of them is sure to be
             the right one for you... If you don't like these, check out the 
             <c>ExtractWithPassword()</c> methods.
             </overloads>
                     
             <seealso cref="P:Ionic.Utils.Zip.ZipEntry.OverwriteOnExtract"/>
             <seealso cref="M:Ionic.Utils.Zip.ZipEntry.Extract(System.Boolean)"/>
            
             <remarks>
             <para>
             Existing entries in the filesystem will not be overwritten. If you would like to 
             force the overwrite of existing files, see the <c>OverwriteOnExtract</c> property, 
             or try one of the overloads of the Extract method that accept a boolean flag
             to indicate explicitly whether you want overwrite.
             </para>
             <para>
             See the remarks on the LastModified property, for some details 
             about how the last modified time of the created file is set.
             </para>
             </remarks>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipEntry.Extract(System.Boolean)">
            <summary>
            Extract the entry to a file in the filesystem, potentially overwriting
            any existing file.
            </summary>
            <remarks>
            <para>
            See the remarks on the LastModified property, for some details 
            about how the last modified time of the created file is set.
            </para>
            </remarks>
            <param name="Overwrite">true if the caller wants to overwrite an existing file by the same name in the filesystem.</param>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipEntry.Extract(System.IO.Stream)">
            <summary>
            Extracts the entry to the specified stream. 
            For example, the caller could specify Console.Out, or a MemoryStream.
            </summary>
            
            <param name="s">the stream to which the entry should be extracted.  </param>
            
            <remarks>
            <para>
            See the remarks on the LastModified property, for some details 
            about how the last modified time of the created file is set.
            </para>
            </remarks>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipEntry.Extract(System.String)">
             <summary>
             Extract the entry to the filesystem, starting at the specified base directory. 
             </summary>
             
             <param name="BaseDirectory">the pathname of the base directory</param>
             
             <seealso cref="P:Ionic.Utils.Zip.ZipEntry.OverwriteOnExtract"/>
             <seealso cref="M:Ionic.Utils.Zip.ZipEntry.Extract(System.String,System.Boolean)"/>
            
             <remarks>
             <para>
             Existing entries in the filesystem will not be overwritten. If you would like to 
             force the overwrite of existing files, see the <c>OverwriteOnExtract</c> property, 
             or try one of the overloads of the Extract method that accept a boolean flag
             to indicate explicitly whether you want overwrite.
             </para>
             <para>
             See the remarks on the LastModified property, for some details 
             about how the last modified time of the created file is set.
             </para>
             </remarks>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipEntry.Extract(System.String,System.Boolean)">
            <summary>
            Extract the entry to the filesystem, starting at the specified base directory, 
            and potentially overwriting existing files in the filesystem. 
            </summary>
            
            <remarks>
            <para>
            See the remarks on the LastModified property, for some details 
            about how the last modified time of the created file is set.
            </para>
            </remarks>
            
            <param name="BaseDirectory">the pathname of the base directory</param>
            <param name="Overwrite">If true, overwrite any existing files if necessary upon extraction.</param>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipEntry.ExtractWithPassword(System.String)">
             <summary>
             Extract the entry to the filesystem, using the current working directory,
             and using the specified password. 
             </summary>
            
             <overloads>
             This method has a bunch of overloads! One of them is sure to be
             the right one for you...
             </overloads>
                     
             <seealso cref="P:Ionic.Utils.Zip.ZipEntry.OverwriteOnExtract"/>
             <seealso cref="M:Ionic.Utils.Zip.ZipEntry.ExtractWithPassword(System.Boolean,System.String)"/>
            
             <remarks>
             <para>
             Existing entries in the filesystem will not be overwritten. If you would like to 
             force the overwrite of existing files, see the <c>OverwriteOnExtract</c> property, 
             or try one of the overloads of the ExtractWithPassword method that accept a boolean flag
             to indicate explicitly whether you want overwrite.
             </para>
             <para>
             See the remarks on the LastModified property, for some details 
             about how the last modified time of the created file is set.
             </para>
             </remarks>
            
             <param name="Password">The Password to use for decrypting the entry.</param>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipEntry.ExtractWithPassword(System.String,System.String)">
             <summary>
             Extract the entry to the filesystem, starting at the specified base directory,
             and using the specified password. 
             </summary>
             
             <seealso cref="P:Ionic.Utils.Zip.ZipEntry.OverwriteOnExtract"/>
             <seealso cref="M:Ionic.Utils.Zip.ZipEntry.ExtractWithPassword(System.String,System.Boolean,System.String)"/>
            
             <remarks>
             <para>
             Existing entries in the filesystem will not be overwritten. If you would like to 
             force the overwrite of existing files, see the <c>OverwriteOnExtract</c> property, 
             or try one of the overloads of the ExtractWithPassword method that accept a boolean flag
             to indicate explicitly whether you want overwrite.
             </para>
             <para>
             See the remarks on the LastModified property, for some details 
             about how the last modified time of the created file is set.
             </para>
             </remarks>
             
             <param name="BaseDirectory">The pathname of the base directory.</param>
             <param name="Password">The Password to use for decrypting the entry.</param>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipEntry.ExtractWithPassword(System.Boolean,System.String)">
            <summary>
            Extract the entry to a file in the filesystem, potentially overwriting
            any existing file.
            </summary>
            
            <remarks>
            <para>
            See the remarks on the LastModified property, for some details 
            about how the last modified time of the created file is set.
            </para>
            </remarks>
            
            <param name="Overwrite">true if the caller wants to overwrite an existing 
            file by the same name in the filesystem.</param>
            <param name="Password">The Password to use for decrypting the entry.</param>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipEntry.ExtractWithPassword(System.String,System.Boolean,System.String)">
            <summary>
            Extract the entry to the filesystem, starting at the specified base directory, 
            and potentially overwriting existing files in the filesystem. 
            </summary>
            
            <remarks>
            See the remarks on the LastModified property, for some details 
            about how the last modified time of the created file is set.
            </remarks>
            
            <param name="BaseDirectory">the pathname of the base directory</param>
            <param name="Overwrite">If true, overwrite any existing files if necessary upon extraction.</param>
            <param name="Password">The Password to use for decrypting the entry.</param>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipEntry.ExtractWithPassword(System.IO.Stream,System.String)">
            <summary>
            Extracts the entry to the specified stream, using the specified Password.
            For example, the caller could extract to Console.Out, or to a MemoryStream.
            </summary>
            
            <remarks>
            See the remarks on the LastModified property, for some details 
            about how the last modified time of the created file is set.
            </remarks>
            
            <param name="s">the stream to which the entry should be extracted.  </param>
            <param name="Password">The Password to use for decrypting the entry.</param>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipEntry.LastModified">
             <summary>
             The time and date at which the file indicated by the ZipEntry was last modified. 
             </summary>
             
             <remarks>
             <para>
             The DotNetZip library sets the LastModified value for an entry, equal to the 
             Last Modified time of the file in the filesystem.  If an entry is added from a stream, 
             in which case no Last Modified attribute is available, the library uses 
             <c>System.DateTime.Now</c> for this value, for the given entry. 
             </para>
            
             <para>
             It is also possible to set the LastModified value on an entry, to an arbitrary
             value.  Be aware that because of the way the PKZip specification describes how
             times are stored in the zip file, the full precision of the
             <c>System.DateTime</c> datatype is not stored in LastModified when saving zip
             files.  For more information on how times are formatted, see the PKZip
             specification.
             </para>
            
             <para>
             The last modified time of the file created upon a call to <c>ZipEntry.Extract()</c> 
             may be adjusted during extraction to compensate
             for differences in how the .NET Base Class Library deals
             with daylight saving time (DST) versus how the Windows
             filesystem deals with daylight saving time. 
             See http://blogs.msdn.com/oldnewthing/archive/2003/10/24/55413.aspx for more context.
             </para>
             <para>
             In a nutshell: Daylight savings time rules change regularly.  In
             2007, for example, the inception week of DST changed.  In 1977,
             DST was in place all year round. In 1945, likewise.  And so on.
             Win32 does not attempt to guess which time zone rules were in
             effect at the time in question.  It will render a time as
             "standard time" and allow the app to change to DST as necessary.
              .NET makes a different choice.
             </para>
             <para>
             Compare the output of FileInfo.LastWriteTime.ToString("f") with
             what you see in the property sheet for a file that was last
             written to on the other side of the DST transition. For example,
             suppose the file was last modified on October 17, during DST but
             DST is not currently in effect. Explorer's file properties
             reports Thursday, October 17, 2003, 8:45:38 AM, but .NETs
             FileInfo reports Thursday, October 17, 2003, 9:45 AM.
             </para>
             <para>
             Win32 says, "Thursday, October 17, 2002 8:45:38 AM PST". Note:
             Pacific STANDARD Time. Even though October 17 of that year
             occurred during Pacific Daylight Time, Win32 displays the time as
             standard time because that's what time it is NOW.
             </para>
             <para>
             .NET BCL assumes that the current DST rules were in place at the
             time in question.  So, .NET says, "Well, if the rules in effect
             now were also in effect on October 17, 2003, then that would be
             daylight time" so it displays "Thursday, October 17, 2003, 9:45
             AM PDT" - daylight time.
             </para>
             <para>
             So .NET gives a value which is more intuitively correct, but is
             also potentially incorrect, and which is not invertible. Win32
             gives a value which is intuitively incorrect, but is strictly
             correct.
             </para>
             <para>
             Because of this funkiness, this library adds one hour to the LastModified time
             on the extracted file, if necessary.  That is to say, if the time in question
             had occurred in what the .NET Base Class Librrary assumed to be DST (an
             assumption that may be wrong given the constantly changing DST rules).
             </para>
             </remarks>
            
        </member>
        <member name="P:Ionic.Utils.Zip.ZipEntry.TrimVolumeFromFullyQualifiedPaths">
            <summary>
            When this is set, this class trims the volume (eg C:\) from any
            fully-qualified pathname on the ZipEntry, before writing the ZipEntry into
            the ZipFile. This flag affects only zip creation. By default, this flag is TRUE,
            which means volume names will not be included in the filenames on entries in
            the archive.  Your best bet is to just leave this alone.
            </summary>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipEntry.ForceNoCompression">
            <summary>
            When this is set, the entry is not compressed when written to 
            the archive.  For example, the application might want to set flag to True
            this when zipping up JPG or MP3 files, which are already compressed.
            </summary>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipEntry.LocalFileName">
            <summary>
            The name of the filesystem file, referred to by the ZipEntry. 
            </summary>
            
            <remarks>
            <para>
            This may be different than the path used in the archive itself. What I mean is, 
            if you call Zip.AddFile("fooo.txt"", AlternativeDirectory), then the 
            path used in the zip entry will be different than this path.  This path is 
            used to locate the thing-to-be-zipped on disk. 
            </para>
            
            <para>
            See also, the <c>FileNameInArchive</c> property. 
            </para>
            </remarks>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipEntry.FileName">
            <summary>
            The name of the file contained in the ZipEntry. 
            When writing a zip, this path has backslashes replaced with 
            forward slashes, according to the zip spec, for compatibility
            with Unix(tm) and ... get this.... Amiga!
            </summary>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipEntry.VersionNeeded">
            <summary>
            The version of the zip engine needed to read the ZipEntry.  This is usually 0x14. 
            (Decimal 20).
            </summary>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipEntry.Comment">
            <summary>
            The comment attached to the ZipEntry. 
            </summary>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipEntry.BitField">
             <summary>
             The bitfield as defined in the zip spec. In the current implementation, the
             only thing this library potentially writes to the general purpose
             Bitfield is an encryption indicators.
             </summary>
             <code>
             bit  0 - set if encryption is used.
             b. 1-2 - set to determine whether normal, max, fast deflation.  
                      This library always leaves these bits unset when writing (indicating 
                      "normal" deflation").
            
             bit  3 - indicates crc32, compressed and uncompressed sizes are zero in
                      local header.  We always leave this as zero on writing, but can read
                      a zip with it nonzero. 
            
             bit  4 - reserved for "enhanced deflating". This library doesn't do enhanced deflating.
             bit  5 - set to indicate the zip is compressed patched data.  This library doesn't do that.
             bit  6 - set if strong encryption is used (must also set bit 1 if bit 6 is set)
             bit  7 - unused
             bit  8 - unused
             bit  9 - unused
             bit 10 - unused
             Bit 11 - Language encoding flag (EFS).  If this bit is set,
                      the filename and comment fields for this file
                      must be encoded using UTF-8. This library currently does not support UTF-8.
             Bit 12 - Reserved by PKWARE for enhanced compression.
             Bit 13 - Used when encrypting the Central Directory to indicate 
                      selected data values in the Local Header are masked to
                      hide their actual values.  See the section describing 
                      the Strong Encryption Specification for details.
             Bit 14 - Reserved by PKWARE.
             Bit 15 - Reserved by PKWARE.
             </code>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipEntry.CompressionMethod">
            <summary>
            The compression method employed for this ZipEntry. 0x08 = Deflate.  0x00 =
            Store (no compression).  Really, this should be an enum.  But the zip spec
            makes it a byte. So here it is. 
            </summary>
            
            <remarks>
            <para>When reading an entry from an existing zipfile, the value you retrieve here
            indicates the compression method used on the entry by the original creator of the zip.  
            When writing a zipfile, you can specify either 0x08 (Deflate) or 0x00 (None).  If you 
            try setting something else, it will throw an exception.  
            </para>
            <para>
            You may wish to set CompressionMethod to 0 (None) when zipping previously compressed
            data like jpg, png, or mp3 files.  This can save time and cpu cycles.
            </para>
            </remarks>
            
            <example>
            In this example, the first entry added to the zip archive uses 
            the default behavior - compression is used where it makes sense.  
            The second entry, the MP3 file, is added to the archive without being compressed.
            <code>
            using (ZipFile zip = new ZipFile(ZipFileToCreate))
            {
              ZipEntry e1= zip.AddFile(@"c:\temp\Readme.txt");
              ZipEntry e2= zip.AddFile(@"c:\temp\StopThisTrain.mp3");
              e2.CompressionMethod = 0;
              zip.Save();
            }
            </code>
            
            <code lang="VB">
            Using zip as new ZipFile(ZipFileToCreate)
              zip.AddFile("c:\temp\Readme.txt")
              Dim e2 as ZipEntry = zip.AddFile("c:\temp\StopThisTrain.mp3")
              e2.CompressionMethod = 0
              zip.Save
            End Using
            </code>
            </example>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipEntry.CompressedSize">
            <summary>
            The compressed size of the file, in bytes, within the zip archive. 
            </summary>
            <remarks>
            The compressed size is computed during compression. This means that it is only
            valid to read this AFTER reading in an existing zip file, or AFTER saving a
            zipfile you are creating.
            </remarks>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipEntry.UncompressedSize">
            <summary>
            The size of the file, in bytes, before compression, or after extraction. 
            </summary>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipEntry.CompressionRatio">
            <summary>
            The ratio of compressed size to uncompressed size. This is a double in the
            range of 0 to 100.  You could print it with a format string of "{3,5:F0}%"
            to see it as a percentage. If the size of the original uncompressed file is 0, 
            the return value will be zero. 
            </summary>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipEntry.IsDirectory">
            <summary>
            True if the entry is a directory (not a file). 
            This is a readonly property on the entry.
            </summary>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipEntry.UsesEncryption">
            <summary>
            A derived property that is True if the entry uses encryption.  
            This is a readonly property on the entry.
            Upon reading an entry, this bool is determined by
            the data read.  When writing an entry, this bool is
            determined by whether the Encryption property is set to something other than
            EncryptionAlgorithm.None. 
            </summary>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipEntry.Encryption">
            <summary>
            Set this to specify which encryption algorithm to use for the entry.
            In order for this to succeed, you must also set a Password on the entry.
            The set of algoritms is determined by the PKZIP specification from PKWare.
            The "traditional" encryption used by PKZIP is considered weak.  PKZip also
            supports strong encryption mechanisms including AES of various keysizes and
            Blowfish, among others.  This library does not implement the full PKZip
            spec. 
            </summary>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipEntry.Password">
            <summary>
            Set this to request that the entry be encrypted when writing the zip
            archive.  This is a write-only property on the entry. The password 
            is used to encrypt the entry during the Save() operation.
            </summary>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipEntry.OverwriteOnExtract">
            <summary>
            Specifies that the extraction should overwrite any existing files.
            This applies only when calling an Extract method. By default this 
            property is false. 
            </summary>
        </member>
        <member name="T:Ionic.Utils.Zip.Shared">
            <summary>
            Collects general purpose utility methods.
            </summary>
        </member>
        <member name="M:Ionic.Utils.Zip.Shared.#ctor">
            private null constructor
        </member>
        <member name="M:Ionic.Utils.Zip.Shared.RoundToEvenSecond(System.DateTime)">
             <summary>
             Round the given DateTime value to an even second value.  
             </summary>
            
             <remarks>
             <para>
             Round up in the case of an odd second value.  The rounding does not consider fractional seconds.
             </para>
             <para>
             This is useful because the Zip spec allows storage of time only to the nearest even second.
             So if you want to compare the time of an entry in the archive with it's actual time in the filesystem, you 
             need to round the actual filesystem time, or use a 2-second threshold for the  comparison. 
             </para>
             <para>
             This is most nautrally an extension method for the DateTime class but this library is 
             built for .NET 2.0, not for .NET 3.5;  This means extension methods are a no-no.  
             </para>
             </remarks>
             <param name="source">The DateTime value to round</param>
             <returns>The ruonded DateTime value</returns>
        </member>
        <member name="M:Ionic.Utils.Zip.Shared.TrimVolumeAndSwapSlashes(System.String)">
            <summary>
            Utility routine for transforming path names. 
            </summary>
            <param name="pathName">source path.</param>
            <returns>transformed path</returns>
        </member>
        <member name="M:Ionic.Utils.Zip.Shared.FindSignature(System.IO.Stream,System.Int32)">
            <summary>
            Finds a signature in the zip stream. This is useful for finding 
            the end of a zip entry, for example. 
            </summary>
            <param name="s"></param>
            <param name="SignatureToFind"></param>
            <returns></returns>
        </member>
        <member name="M:Ionic.Utils.Zip.Shared.StringToMemoryStream(System.String)">
            <summary>
            Creates a <c>MemoryStream</c> for the given string. This is used internally by Library, specifically by 
            the ZipFile.AddStringAsFile() method.   But it may be useful in other scenarios. 
            </summary>
            <param name="s">The string to use as input for the MemoryStream</param>
            <returns>the MemoryStream. Reading the stream will give you the content of the String.</returns>
        </member>
        <member name="T:Ionic.Utils.Zip.CountingOutputStream">
            <summary>
            A write-only Stream, used for bookkeeping on ASP.NET output streams.
            </summary>
        </member>
        <member name="M:Ionic.Utils.Zip.CountingOutputStream.#ctor(System.IO.Stream)">
            <summary>
            The  constructor.
            </summary>
            <param name="s">The underlying stream</param>
        </member>
        <member name="T:Ionic.Utils.Zip.CRC32">
            <summary>
            Calculates a 32bit Cyclic Redundancy Checksum (CRC) using the
            same polynomial used by Zip. This type ie generally not used directly
            by applications wishing to create, read, or manipulate zip archive files.
            </summary>
        </member>
        <member name="M:Ionic.Utils.Zip.CRC32.GetCrc32(System.IO.Stream)">
            <summary>
            Returns the CRC32 for the specified stream.
            </summary>
            <param name="input">The stream over which to calculate the CRC32</param>
            <returns>the CRC32 calculation</returns>
        </member>
        <member name="M:Ionic.Utils.Zip.CRC32.GetCrc32AndCopy(System.IO.Stream,System.IO.Stream)">
            <summary>
            Returns the CRC32 for the specified stream, and writes the input into the output stream.
            </summary>
            <param name="input">The stream over which to calculate the CRC32</param>
            <param name="output">The stream into which to deflate the input</param>
            <returns>the CRC32 calculation</returns>
        </member>
        <member name="M:Ionic.Utils.Zip.CRC32.ComputeCrc32(System.UInt32,System.Byte)">
            <summary>
            Get the CRC32 for the given (word,byte) combo. 
            This is a computation defined by PKzip.
            </summary>
            <param name="W">The word to start with.</param>
            <param name="B">The byte to combine it with.</param>
            <returns>The CRC-ized result.</returns>
        </member>
        <member name="M:Ionic.Utils.Zip.CRC32.SlurpBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the value for the running CRC32 using the given block of bytes.
            This is useful when using the CRC32() class in a Stream.
            </summary>
            <param name="block">block of bytes to slurp</param>
            <param name="offset">starting point in the block</param>
            <param name="count">how many bytes within the block to slurp</param>
        </member>
        <member name="M:Ionic.Utils.Zip.CRC32.#ctor">
            <summary>
            Construct an instance of the CRC32 class, pre-initialising the table
            for speed of lookup.
            </summary>
        </member>
        <member name="P:Ionic.Utils.Zip.CRC32.TotalBytesRead">
            <summary>
            indicates the total number of bytes read on the CRC stream.
            This is used when writing the ZipDirEntry when compressing files.
            </summary>
        </member>
        <member name="P:Ionic.Utils.Zip.CRC32.Crc32Result">
            <summary>
            Indicates the current CRC for all blocks slurped in.
            </summary>
        </member>
        <member name="T:Ionic.Utils.Zip.CrcCalculatorStream">
            <summary>
            A read-only Stream for reading and concurrently calculating a CRC.
            </summary>
        </member>
        <member name="M:Ionic.Utils.Zip.CrcCalculatorStream.#ctor(System.IO.Stream)">
            <summary>
            The  constructor.
            </summary>
            <param name="s">The underlying stream</param>
        </member>
        <member name="P:Ionic.Utils.Zip.CrcCalculatorStream.Crc32">
            <summary>
            Indicates the current CRC for all blocks slurped in.
            </summary>
        </member>
        <member name="T:Ionic.Utils.Zip.SaveProgressEventArgs">
            <summary>
            Base class used to provide information about the download progress.
            </summary>
        </member>
        <member name="M:Ionic.Utils.Zip.SaveProgressEventArgs.#ctor(System.Int32,System.Int32,System.String)">
            <summary>
            Constructor for the SaveProgressEventArgs.
            </summary>
            <param name="entriesTotal">The total number of entries in the zip archive.</param>
            <param name="entriesSaved">Number of bytes that have been transferred.</param>
            <param name="lastEntry">The last entry saved.</param>
        </member>
        <member name="P:Ionic.Utils.Zip.SaveProgressEventArgs.EntriesTotal">
            <summary>
            The total number of entries to be saved.
            </summary>
        </member>
        <member name="P:Ionic.Utils.Zip.SaveProgressEventArgs.EntriesSaved">
            <summary>
            Number of entries saved so far.
            </summary>
        </member>
        <member name="P:Ionic.Utils.Zip.SaveProgressEventArgs.NameOfLatestEntry">
            <summary>
            the name of the last entry saved.
            </summary>
        </member>
        <member name="P:Ionic.Utils.Zip.SaveProgressEventArgs.Cancel">
            <summary>
            Indicates whether the operation was cancelled or not.
            </summary>
        </member>
        <member name="T:Ionic.Utils.Zip.SaveEventArgs">
            <summary>
            Used to provide event information about the Save .
            </summary>
        </member>
        <member name="M:Ionic.Utils.Zip.SaveEventArgs.#ctor(System.String)">
            <summary>
            Constructor for a SaveEventArgs.
            </summary>
            <param name="archiveName">The name of the archive being saved.</param>
        </member>
        <member name="P:Ionic.Utils.Zip.SaveEventArgs.ArchiveName">
            <summary>
            Returns the archive name.
            </summary>
        </member>
        <member name="T:Ionic.Utils.Zip.SaveProgressEventHandler">
            <summary>
            Delegate for the SaveProgress event.
            </summary>
            <param name="sender">The sender of the event.</param>
            <param name="e">The information about the event.</param>
        </member>
        <member name="T:Ionic.Utils.Zip.SaveStartedEventHandler">
            <summary>
            Delegate for the SaveStarted event.
            </summary>
            <param name="sender">The sender of the event.</param>
            <param name="e">The information about the event.</param>
        </member>
        <member name="T:Ionic.Utils.Zip.SaveCompletedEventHandler">
            <summary>
            Delegate for the SaveCompleted event.
            </summary>
            <param name="sender">The sender of the event.</param>
            <param name="e">The information about the event.</param>
        </member>
        <member name="T:Ionic.Utils.Zip.ZipDirEntry">
            <summary>
            This class models an entry in the directory contained within the zip file.
            The class is generally not used from within application code, though it is
            used by the ZipFile class.
            </summary>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipDirEntry.Read(System.IO.Stream)">
            <summary>
            Reads one entry from the zip directory structure in the zip file. 
            </summary>
            <param name="s">the stream from which to read.</param>
            <returns>the entry read from the archive.</returns>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipDirEntry.IsNotValidSig(System.Int32)">
            <summary>
            Returns true if the passed-in value is a valid signature for a ZipDirEntry. 
            </summary>
            <param name="signature">the candidate 4-byte signature value.</param>
            <returns>true, if the signature is valid according to the PKWare spec.</returns>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipDirEntry.LastModified">
            <summary>
            The time at which the file represented by the given entry was last modified.
            </summary>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipDirEntry.FileName">
            <summary>
            The filename of the file represented by the given entry.
            </summary>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipDirEntry.Comment">
            <summary>
            Any comment associated to the given entry. Comments are generally optional.
            </summary>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipDirEntry.VersionMadeBy">
            <summary>
            The version of the zip engine this archive was made by.  
            </summary>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipDirEntry.VersionNeeded">
            <summary>
            The version of the zip engine this archive can be read by.  
            </summary>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipDirEntry.CompressionMethod">
            <summary>
            The compression method used to generate the archive.  Deflate is our favorite!
            </summary>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipDirEntry.CompressedSize">
            <summary>
            The size of the file, after compression. This size can actually be 
            larger than the uncompressed file size, for previously compressed 
            files, such as JPG files. 
            </summary>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipDirEntry.UncompressedSize">
            <summary>
            The size of the file before compression.  
            </summary>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipDirEntry.IsDirectory">
            <summary>
            True if the referenced entry is a directory.  
            </summary>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipDirEntry.CompressionRatio">
            <summary>
            The calculated compression ratio for the given file. 
            </summary>
        </member>
        <member name="T:Ionic.Utils.Zip.ZipCrypto">
            <summary> 
            This class implements the "traditional" or "classic" PKZip encryption,
            which today is considered to be weak. On the other hand it is
            ubiquitous. This class is intended for use only by the DotNetZip library.
            </summary>
            <remarks>
            Most uses of the DotNetZip library will not involve direct calls into the
            ZipCrypto class.  Instead, the ZipCrypto class is instantiated and used by
            the ZipEntry() class when encryption or decryption on an entry is employed.
            If for some reason you really wanted to use a weak encryption algorithm
            in some other application, you might use this library.  But you would be much
            better off using one of the built-in strong encryption libraries in the 
            .NET Framework, like the AES algorithm or SHA. 
            </remarks>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipCrypto.#ctor">
            <summary>
            The default constructor.  You're probably never gonna call this.  Seriously.
            Stop reading this documentation.  It's not useful to you.  Go do something else.
            Check the football scores. Go get an ice cream with a friend.  Seriously.
            </summary>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipCrypto.DecryptMessage(System.Byte[],System.Int32)">
            <summary> 
            Call this method on a cipher text to render the plaintext. You must
            first initialize the cipher with a call to InitCipher.
            </summary>		
            <example>
            <code>
            var cipher = new ZipCrypto();
            cipher.InitCipher(Password);
            // Decrypt the header.  This has a side effect of "further initializing the
            // encryption keys" in the traditional zip encryption. 
            byte[] DecryptedMessage = cipher.DecryptMessage(EncryptedMessage);
            </code>
            </example>
            <param name="CipherText">The encrypted buffer.</param>
            <param name="length">
            The number of bytes to encrypt.  
            Should be less than or equal to CipherText.Length.
            </param>
            <returns>The plaintext.</returns>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipCrypto.EncryptMessage(System.Byte[],System.Int32)">
            <summary>
            This is the converse of DecryptMessage.  It encrypts the plaintext
            and produces a ciphertext. 
            </summary>
            <param name="PlainText">The plain text buffer.</param>
            <param name="length">
            The number of bytes to encrypt.  
            Should be less than or equal to PlainText.Length.
            </param>
            <returns>The ciphertext.</returns>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipCrypto.InitCipher(System.String)">
             <summary>
             This initializes the cipher with the given password. 
             See AppNote.txt for details. 
             </summary>
             <param name="Passphrase">The passphrase for encrypting or decrypting with this cipher.
             </param>
             <remarks>
             <code>
             Step 1 - Initializing the encryption keys
             -----------------------------------------
             Start with these keys:        
             Key(0) := 305419896 (0x12345678)
             Key(1) := 591751049 (0x23456789)
             Key(2) := 878082192 (0x34567890)
             
             Then, initialize the keys with a password:
             
             loop for i from 0 to length(password)-1
                 update_keys(password(i))
             end loop
             
             Where update_keys() is defined as:
             
             update_keys(char):
               Key(0) := crc32(key(0),char)
               Key(1) := Key(1) + (Key(0) bitwiseAND 000000ffH)
               Key(1) := Key(1) * 134775813 + 1
               Key(2) := crc32(key(2),key(1) rightshift 24)
             end update_keys
             
             Where crc32(old_crc,char) is a routine that given a CRC value and a
             character, returns an updated CRC value after applying the CRC-32
             algorithm described elsewhere in this document.
            
             </code>
             <para>
             After the keys are initialized, then you can use the cipher to encrypt
             the plaintext. 
             </para>
             <para>
             Essentially we encrypt the password with the keys, then discard the 
             ciphertext for the password. This initializes the keys for later use.
             </para>
             </remarks>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipCrypto.MagicByte">
            <summary> 
            From AppNote.txt:
            unsigned char decrypt_byte()
                local unsigned short temp
                temp :=- Key(2) | 2
                decrypt_byte := (temp * (temp ^ 1)) bitshift-right 8
            end decrypt_byte
            </summary>		
        </member>
        <member name="T:Ionic.Utils.Zip.ZipCipherInputStream">
            <summary>
            A read-only Stream for reading and concurrently decrypting data from a zip file.
            </summary>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipCipherInputStream.#ctor(System.IO.Stream,Ionic.Utils.Zip.ZipCrypto)">
            <summary>
            The  constructor.
            </summary>
            <param name="s">The underlying stream</param>
            <param name="cipher">The pre-initialized ZipCrypto object.</param>
        </member>
    </members>
</doc>
